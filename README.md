# Beam-Dataset-SE
__A dataset about beams__

The purpose of building up this dataset is for monocular image based 3D beam reconstruction.

The dataset can be download from the link below:

https://www.google.com/search?q=read+paper&rlz=1C1GCEA_enAU1032AU

There are three folders: __beams, simple_support_beam and simple_support_beam_images in the dataset.__
# beams
This folder contains __400__ rectangular mesh cuboid beams generated by __Trimesh API__. The beams are generated based on the different ratio of length, width and height, in which some of them are 'fat' and some of them are 'thin'. More details:

__1. Calculate the ratio between length and width:__
The ratio between the length and width can be expressed as:
length : width = 1 : (0.25 to 0.02)
This means that the width can vary between 0.25 and 0.02 times the length.
And we genrate 20 different width based on the function below:

    widths = [max_rate  - (i / (num_rates - 1))**0.85 * (max_rate - min_rate) for i in range(num_rates)].

    In this dataset: max_rate = 0.25, min_rate = 0.02, num_rates = 20. 
    
__2. Calculate the ratio between width and height:__
Based on the width calculated in the previous step, we then determine the ratio between width and height. 20 ratios between the height and width, ranging from 0.05 to 1.5 are generated.

They are evenly distributed as:
```python
np.linspace(0.05, 1.5, 20).
```

The size of the beam can be found from the file: '/beams/mesh_meta'.

Each beam has __6147 vertices__ and __12288 face normals__.  

# simple_support_beam
This folder contains 7200 deformed simple support beams. 



They are generated by using the analytic solution below:

```python
# P: the applied load.
# a: the location along the beam where the applied load or force P is acting. 
# E: Young's modulus of the material.
# I: the moment of inertia of the cross-sectional shape of the beam.
def simple_support_beam(mesh, P, a, E, I):
    L = 1  # Assuming the length of the beam is along the x-axis
    for vertic in mesh.vertices:
        x = vertic[0]
        if x < a:
            y = (P * (L - a) * x * (L**2 - x**2 - (L - a)**2)) / (6 * L * E * I)
        else:
            y = (P * a * (L - x) * (L**2 - (L - x)**2 - a**2)) / (6 * L * E * I)
        vertic[1] += y  # Add the deflection to the y-coordinate of the vertex
    return mesh
```
# simple_support_beam_images
